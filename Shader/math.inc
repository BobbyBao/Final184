const float PI = 3.1415926f;
const float half_PI = PI / 2.0f;
const float PI2 = PI * 2.0;

vec2 spherical(float phi) {
    return vec2(cos(phi), sin(phi));
}

// Pseudo-random generation, vec2 -> float
float rand21(vec2 co) {
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float fastSqrt(float x) {
    return intBitsToFloat(0x1FBD1DF5 + (floatBitsToInt(x) >> 1));
}

vec2 fastSqrt(vec2 x) {
    return intBitsToFloat(0x1FBD1DF5 + (floatBitsToInt(x) >> 1));
}

float fastAcos(float x) {
    float res = -0.156583 * abs(x) + half_PI;
    res *= fastSqrt(1.0 - abs(x));
    return x >= 0 ? res : PI - res;
}

vec2 fastAcos(vec2 x) {
    vec2 res = -0.156583 * abs(x) + half_PI;
    res *= fastSqrt(1.0 - abs(x));
    vec2 flag = step(x, vec2(0.0));
    return res * fma(-flag, vec2(2.0), vec2(1.0)) + flag * vec2(PI);
}

float w0(float a) {
    return (1.0/6.0)*(a*(a*(-a + 3.0) - 3.0) + 1.0);
}

float w1(float a) {
    return (1.0/6.0)*(a*a*(3.0*a - 6.0) + 4.0);
}

float w2(float a) {
    return (1.0/6.0)*(a*(a*(-3.0*a + 3.0) + 3.0) + 1.0);
}

float w3(float a) {
    return (1.0/6.0)*(a*a*a);
}

// g0 and g1 are the two amplitude functions
float g0(float a) {
    return w0(a) + w1(a);
}

float g1(float a) {
    return w2(a) + w3(a);
}

// h0 and h1 are the two offset functions
float h0(float a) {
    return -1.0 + w1(a) / (w0(a) + w1(a));
}

float h1(float a) {
    return 1.0 + w3(a) / (w2(a) + w3(a));
}

vec3 hemisphereSample_uniform(float u, float v) {
    float phi = v * 2.0 * PI;
    float cosTheta = 1.0 - u;
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
}
    
vec3 hemisphereSample_cos(float u, float v) {
    float phi = v * 2.0 * PI;
    float cosTheta = sqrt(1.0 - u);
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
}

float hash(vec2 p) {
	vec3 p3 = fract(vec3(p.xyx) * 0.2031);
	p3 += dot(p3, p3.yzx + 19.19);
	return fract((p3.x + p3.y) * p3.z);
}

float noise(vec2 p) {
	vec2 i = floor(p);
	vec2 f = fract(p);
	vec2 u = (f * f) * fma(vec2(-2.0f), f, vec2(3.0f));
	return fma(2.0f, mix(
		mix(hash(i),                      hash(i + vec2(1.0f,0.0f)), u.x),
		mix(hash(i + vec2(0.0f,1.0f)), hash(i + vec2(1.0f,1.0f)), u.x),
	u.y), -1.0f);
}

float iiTime;
vec2 hash22(vec2 p) {
    vec3 p3 = fract(p.xyx * vec3(9.1031, 8.1030, 7.0973));
    p3 += dot(p3, p3.yzx+19.19);
    return fract((p3.x+p3.yz)*p3.zy);
}

//note: uniformly distributed, normalized rand, [0;1[
float nrand( vec2 n )
{
	return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);
}
//note: remaps v to [0;1] in interval [a;b]
float remap( float a, float b, float v )
{
	return clamp( (v-a) / (b-a), 0.0, 1.0 );
}
//note: quantizes in l levels
float truncate( float a, float l )
{
	return floor(a*l)/l;
}

float n1rand( vec2 n )
{
	float t = fract( iiTime );
	float nrnd0 = nrand( n + 0.07*t );
	return nrnd0;
}
float n2rand( vec2 n )
{
	float t = fract( iiTime );
	float nrnd0 = nrand( n + 0.07*t );
	float nrnd1 = nrand( n + 0.11*t );
	return (nrnd0+nrnd1) / 2.0;
}

float n2rand_faster( vec2 n )
{
	float t = fract( iiTime );
	float nrnd0 = nrand( n + 0.07*t );

    // Convert uniform distribution into triangle-shaped distribution.
    float orig = nrnd0*2.0-1.0;
    nrnd0 = orig*inversesqrt(abs(orig));
    nrnd0 = max(-1.0,nrnd0); // Nerf the NaN generated by 0*rsqrt(0). Thanks @FioraAeterna!
    nrnd0 = nrnd0-sign(orig)+0.5;
    
    // Result is range [-0.5,1.5] which is
    // useful for actual dithering.
    // convert to [0,1] for histogram.
    return (nrnd0+0.5) * 0.5;
}
float n2rand_tri(vec2 n) {
    n += 0.07* fract(iiTime);
    return dot(hash22(n), vec2(1))*0.5;
}
float n3rand( vec2 n )
{
	float t = fract( iiTime );
	float nrnd0 = nrand( n + 0.07*t );
	float nrnd1 = nrand( n + 0.11*t );
	float nrnd2 = nrand( n + 0.13*t );
	return (nrnd0+nrnd1+nrnd2) / 3.0;
}
float n4rand( vec2 n )
{
	float t = fract( iiTime );
	float nrnd0 = nrand( n + 0.07*t );
	float nrnd1 = nrand( n + 0.11*t );	
	float nrnd2 = nrand( n + 0.13*t );
	float nrnd3 = nrand( n + 0.17*t );
	return (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;
}
float n4rand_inv( vec2 n )
{
	float t = fract( iiTime );
	float nrnd0 = nrand( n + 0.07*t );
	float nrnd1 = nrand( n + 0.11*t );	
	float nrnd2 = nrand( n + 0.13*t );
	float nrnd3 = nrand( n + 0.17*t );
    float nrnd4 = nrand( n + 0.19*t );
	float v1 = (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;
    float v2 = 0.5 * remap( 0.0, 0.5, v1 ) + 0.5;
    float v3 = 0.5 * remap( 0.5, 1.0, v1 );
    return (nrnd4<0.5) ? v2 : v3;
}

//alternate Gaussian,
//thanks to @self_shadow
float n4rand_ss( vec2 n )
{
	float nrnd0 = nrand( n + 0.07*fract( iiTime ) );
	float nrnd1 = nrand( n + 0.11*fract( iiTime + 0.573953 ) );	
	return 0.23*sqrt(-log(nrnd0+0.00001))*cos(2.0*3.141592*nrnd1)+0.5;
}

float blugausnoise(vec2 c1) {
    c1 += 0.07* fract(iiTime);
    //vec2 c0 = vec2(c1.x- 1.,c1.y);
    //vec2 c2 = vec2(c1.x+ 1.,c1.y);
    vec3 cx = c1.x+ vec3(-1,0,1);
    vec4 f0 = fract(vec4(cx* 9.1031,c1.y* 8.1030));
    vec4 f1 = fract(vec4(cx* 7.0973,c1.y* 6.0970));
	vec4 t0 = vec4(f0.xw,f1.xw);//fract(c0.xyxy* vec4(.1031,.1030,.0973,.0970));
	vec4 t1 = vec4(f0.yw,f1.yw);//fract(c1.xyxy* vec4(.1031,.1030,.0973,.0970));
	vec4 t2 = vec4(f0.zw,f1.zw);//fract(c2.xyxy* vec4(.1031,.1030,.0973,.0970));
    vec4 p0 = t0+ dot(t0,t0.wzxy+ 19.19);
    vec4 p1 = t1+ dot(t1,t1.wzxy+ 19.19);
    vec4 p2 = t2+ dot(t2,t2.wzxy+ 19.19);
	vec4 n0 = fract(p0.zywx* (p0.xxyz+ p0.yzzw));
	vec4 n1 = fract(p1.zywx* (p1.xxyz+ p1.yzzw));
	vec4 n2 = fract(p2.zywx* (p2.xxyz+ p2.yzzw));
    return dot(0.5* n1- 0.125* (n0+ n2),vec4(1));
}
float blugausnoise2(vec2 c1) {
    float nrand1 = n4rand_ss(c1);
    float nrand0 = n4rand_ss(vec2(c1.x- 1.,c1.y));
    float nrand2 = n4rand_ss(vec2(c1.x+ 1.,c1.y));
    return 2.0* nrand1- 0.5* (nrand0+ nrand2);
}

float bayer2(vec2 a){
    a = floor(a);
    return fract( dot(a, vec2(.5f, a.y * .75f)) );
}

#define bayer4(a)   (bayer2( .5f*(a))*.25f+bayer2(a))
#define bayer8(a)   (bayer4( .5f*(a))*.25f+bayer2(a))
#define bayer16(a)  (bayer8( .5f*(a))*.25f+bayer2(a))
#define bayer32(a)  (bayer16(.5f*(a))*.25f+bayer2(a))
#define bayer64(a)  (bayer32(.5f*(a))*.25f+bayer2(a))